#include<stdio.h>
#include<stdlib.h>

//常量
#define PROCESS_NAME_LEN 32     //进程名长度
#define MIN_SLICE 10            //最小碎片大小
#define DEFAULT_MEM_SIZE 1024   //内存大小
#define DEFAULT_MEM_START 0     //起始位置

//分配到内存块的描述
struct get_block {
    int pid;
    int size;
    int start_addr;
    char process_name[PROCESS_NAME_LEN];
    struct get_block* next;
};

//内存空闲分区
struct free_block {
    int size;
    int start_addr;
    struct free_block* next;
};


//内存分配算法
#define MA_FF 1
#define MA_BF 2
#define MA_WF 3

int mem_size = DEFAULT_MEM_SIZE;    //内存大小
int ma_algorithm = MA_FF;           //当前算法
static int pid = 0;                 //初始化pid
int flag = 0;                       //设置内存大小标志

//函数声明
int display_menu(void);         //展示功能菜单
int set_mem_size(void);         //设置申请内存空间大小
int set_algorithm(void);        //设置算法
int rearrange_FF(void);         //首次适配算法
int rearrange_BF(void);         //最优适配算法
int rearrange_WF(void);         //最坏适配算法

int kill_process(void);         //删除进程，归还分配的储存空间
int do_exit(void);              //退出程序，释放空间
int display_mem_usage(void) ;   //显示当前内存的使用情况，包括空闲区和已经分配的情况
int rearrange(int algorithm) ;              //选择算法


int free_mem(struct get_block *ab);     //释放链表
int allocate_mem(struct get_block *ab);     //分配内存模块
int dispose(struct get_block* free_ab);     //处理free后的链表

int FF(void);           //按地址由低到高排序
int BF(void);           //按内存大小由小到大排序
int WF(void);           //按内存大小由大到小排序
struct get_block* find_process(int pid);            //按pid找到需要释放的链表节点
struct free_block* init_free_block(int mem_size);   //初始化空闲块


struct free_block* free_b;//内存空闲块来链表的首指针



struct get_block* get_block_head = NULL; //进程分配内存块链表的首指针

struct free_block*  init_free_block(int mem_size) {
    struct free_block *fb,*ptemp;
    get_block_head = (struct get_block*)malloc(sizeof(struct get_block));
    fb = (struct free_block*)malloc(sizeof(struct free_block));
    ptemp=(struct free_block*)malloc(sizeof(struct free_block));
    if (fb == NULL) {
        printf("No nen \n");
    }
    get_block_head->next=NULL;
    fb->next=ptemp;
    ptemp->size = mem_size;
    ptemp->start_addr = DEFAULT_MEM_START;
    ptemp->next = NULL;
    return fb;
}

int  display_menu()
{
    printf("\n");
    printf("1- Set memory size (%d)\n",mem_size);
    printf("2- Select memory size allocation algorithm \n");
    printf("3- New process \n");
    printf("4- Terminate a process \n");
    printf("5- Display memory usage \n");
    printf("0- Exit\n");
    return 1;
}

int set_mem_size() {
    int size;
    if (flag != 0) {//防止重复设置
        printf("Cannot set memory size again\n");
        return 0;
    }
    printf("Total memory size =");
    scanf("%d", &size);
    if (size>0) {
        mem_size = size;
        free_b->next->size = mem_size;
    }
    flag = 1;
    return 1;
}
int FF(){
    struct free_block* fbh=free_b->next;
    struct free_block* fbp=free_b->next;
    int sizep;
    int addrp;
    while(fbh!=NULL){
        while(fbp->next!=NULL){
                if(fbp->start_addr>fbp->next->start_addr){
                    addrp=fbp->start_addr;
                    fbp->start_addr=fbp->next->start_addr;
                    fbp->next->start_addr=addrp;
                    sizep=fbp->size;
                    fbp->size=fbp->next->size;
                    fbp->next->size=sizep;
                }
                fbp=fbp->next;
        }
        fbp=free_b->next;
        fbh=fbh->next;
    }
    while(fbh!=NULL){
        printf("%d,%d",fbh->size,fbh->start_addr);
        fbh=fbh->next;
    }
    return 0;
}

int rearrange_FF() {
    FF();
    return 0;
}

int BF(){
    struct free_block* fbh=free_b->next;
    struct free_block* fbp=free_b->next;
    int sizep;
    int addrp;
    while(fbh!=NULL){
        while(fbp->next!=NULL){
                if(fbp->size>fbp->next->size){
                    addrp=fbp->start_addr;
                    fbp->start_addr=fbp->next->start_addr;
                    fbp->next->start_addr=addrp;
                    sizep=fbp->size;
                    fbp->size=fbp->next->size;
                    fbp->next->size=sizep;
                }
                fbp=fbp->next;
        }
        fbp=free_b->next;
        fbh=fbh->next;
    }
    while(fbh!=NULL){
        printf("%d,%d",fbh->size,fbh->start_addr);
        fbh=fbh->next;
    }
    return 0;
}

int rearrange_BF() {
    BF();
    return 0;
}

int WF(){
    struct free_block* fbh=free_b->next;
    struct free_block* fbp=free_b->next;
    int sizep;
    int addrp;
    while(fbh!=NULL){
        while(fbp->next!=NULL){
                if(fbp->size<fbp->next->size){
                    addrp=fbp->start_addr;
                    fbp->start_addr=fbp->next->start_addr;
                    fbp->next->start_addr=addrp;
                    sizep=fbp->size;
                    fbp->size=fbp->next->size;
                    fbp->next->size=sizep;
                }
                fbp=fbp->next;
        }
        fbp=free_b->next;
        fbh=fbh->next;
    }
    while(fbh!=NULL){
        printf("%d,%d",fbh->size,fbh->start_addr);
        fbh=fbh->next;
    }
    return 0;
}

int rearrange_WF() {
    WF();
    return 0;
}

int rearrange(int algorithm) {
    switch (algorithm) {
    case MA_FF: rearrange_FF(); break;
    case MA_BF:rearrange_BF(); break;
    case MA_WF:rearrange_WF(); break;
    }
    return 0;
}

int set_algorithm() {
    int algorithm;
    printf("\t1 - First Fit \n");
    printf("\t2 - Best Fit \n");
    printf("\t3 - Worst Fit \n");
    scanf("%d", &algorithm);
    if (algorithm >= 1 && algorithm <= 3) {
        ma_algorithm = algorithm;
        //按指定算法重新排列空闲区链表
        rearrange(ma_algorithm);
    }
    return 0;
}

int allocate_mem(struct get_block *ab) {    //分配内存模块
    struct free_block* fbt, *pre;
    int request_size = ab->size;
    fbt = pre = free_b->next;
    while(fbt!=NULL){
        if(fbt->size>=request_size){
            ab->start_addr=fbt->start_addr+fbt->size-request_size;
            fbt->size=fbt->size-request_size;
            return 1;
        }
        else {
            pre=fbt;
            fbt=fbt->next;
        }
    }
    printf("空闲区不够！\n");
    return 0;
}

int new_process() {
    int size,ret;
    struct get_block *ab,*temp;
    ab = (struct get_block*)malloc(sizeof(struct get_block));
    temp=get_block_head->next;
    if (!ab) {
        exit(-5);
    }
    ab->next = NULL;
    pid++;
    sprintf(ab->process_name, "PROCESS-%02d", pid);
    ab->pid = pid;
    printf("Memory for %s:\n", ab->process_name);
    scanf("%d", &size);
    ab->size = size;
    ret = allocate_mem(ab);     //从空闲区分配内存，ret==1表示分配完成
    if ((ret == 1) && (get_block_head->next == NULL)) {//get_b_h没有赋值，进行赋值
        get_block_head->next= ab;
        printf("ret==1");
        return 1;
    }
    else if (ret == 1) {
        printf("分配成功\n");
        while(temp->next!=NULL){
            temp=temp->next;
        }

        temp->next=ab;
        return 2;
    }
    else if (ret == -1) {
        printf("Allocation fail\n");
        free(ab);
        return 1;
    }
    return 3;
}

struct get_block* find_process(int pid){
    struct get_block* get_temp=get_block_head;
    while(get_temp!=NULL){
        if(get_temp->pid==pid){
            return get_temp;
        }
        else{
            get_temp=get_temp->next;
        }
    }
    printf("操作错误\n");
    return NULL;
}

int free_mem(struct get_block *ab) {
    int algorithm = ma_algorithm;
    struct free_block *fbt, *pre, *work;
    fbt = (struct free_block*) malloc(sizeof(struct free_block));
    if (!fbt) return -1;
    // 进行可能的合并，基本策略如下
    // 1. 将新释放的结点插入到空闲分区队列末尾
    // 2. 对空闲链表按照地址有序排列
    // 3. 检查并合并相邻的空闲分区
    // 4. 将空闲链表重新按照当前算法排序
    fbt->size=ab->size;
    fbt->start_addr=ab->start_addr;
    pre=free_b->next;
    while(pre->next!=NULL){
        pre=pre->next;
    }
    pre->next=fbt;
    fbt->next=NULL;
    FF();
    pre=free_b->next;
    while(pre->next!=NULL){
        if(pre->start_addr+pre->size==pre->next->start_addr){
            pre->size=pre->size+pre->next->size;
            if(pre->next->next!=NULL){
                pre->next=pre->next->next;
            }else{
                    pre->next=NULL;
                    break;
            }
        }
        pre=pre->next;
    }
    pre=free_b->next;
    while(pre->next!=NULL){
        if(pre->start_addr+pre->size==pre->next->start_addr){
            pre->size=pre->size+pre->next->size;
            if(pre->next->next!=NULL){
                pre->next=pre->next->next;
            }else{
                    pre->next=NULL;
                    break;
            }
        }
        pre=pre->next;
    }
    printf("内存紧缩完成");
    rearrange(ma_algorithm);
    return 1;
}

int dispose(struct get_block* free_ab){
    struct get_block *pre, *ab;
    if (free_ab == get_block_head) {//如果要释放第一个节点
        get_block_head = get_block_head->next;
        free(free_ab);
        return 1;
    }
    pre = get_block_head;
    ab = get_block_head->next;
    while (ab != free_ab) {
        pre = ab;
        ab = ab->next;
    }
    pre->next = ab->next;
    free(ab);
    return 2;
}

int display_mem_usage() {//显示当前内存的使用情况，包括空闲区和已经分配的情况
    struct free_block *fbt = free_b->next;
    struct get_block *ab = get_block_head->next;

    if (fbt == NULL) return 1;
    printf("------------------------------------\n");

    //显示空闲区
    printf("Free Memory:\n");
    while(fbt!=NULL){
        printf("%20d%20d\n", fbt->start_addr, fbt->size);
        fbt = fbt->next;
    }
    //显示已分配区
    printf("\nUsed Memory:\n");
    printf("%10s %20s %10s %10s \n", "PID", "ProcessName    ", "start_addr", "size");
    while (ab != NULL) {
        printf("%10d %20s %10d %10d \n",ab->pid,ab->process_name,ab->start_addr,ab->size);
        ab = ab->next;
    }
    printf("------------------------------------------\n");
    return 0;
}
int kill_process() {//删除进程，归还分配的储存空间
                    //，删除描述该进程的内存分配的节点
    struct get_block *ab;
    int pid;
    printf("Kill Process , pid =");
    scanf("%d",&pid);
    ab = find_process(pid);
    if (ab != NULL) {
        free_mem(ab);//释放ab表示的分配区
        dispose(ab);//释放ab数据结构的节点
    }
    return 0;
}
int do_exit() {
    struct get_block *temp;
    while (get_block_head != NULL) {
        temp = get_block_head;
        get_block_head = get_block_head->next;
        free(temp);
    }
    return 0;
}
int main() {
    char choice;
    pid = 0;
    free_b = init_free_block(mem_size);//初始化空闲区
    while (1) {
        display_menu();//显示菜单
        fflush(stdin);
        choice = getchar();//获取用户输入
        switch (choice) {
        case'1':set_mem_size();flag=1;break;        //设置内存大小
        case'2':set_algorithm(); flag = 1; break;   //设置算法
        case'3':new_process(); flag = 1; break;     //创建新进程
        case'4':kill_process(); flag = 1; break;    //删除进程
        case'5':display_mem_usage(); flag = 1; break;//显示内存使用
        case'0': do_exit(); exit(0);                //释放链表退出
        default:break;
        }
    }
}
